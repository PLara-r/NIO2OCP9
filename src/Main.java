import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {

    public static void main(String[] args) {
        //Самый простой и простой способ получить Pathобъект - использовать java.nio.files.Paths
        // фабричный класс или, если Pathsкоротко. Чтобы получить ссылку на файл илидиректории,
        // вы бы вызвали staticметод Paths.getPath(String)метода, как показано в примерe:
        Path path2 = Paths.get("C:\\Users\\Kosty\\OCP8BufferedReader\\src\\Zoo.csv");

        //Другой способ построить с Pathиспользованием Pathsкласса является со значением URI.
        // uniform resource identifier(URI) представляет собой строку символов , которые идентифицируют ресурс.
        // Он начинается со схемы, которая указывает тип ресурса, за которым следует значение пути. Примеры значений схемы включают в себя file://, http://, https://, и ftp://. java.net.URIКласс используется
        // для создания и управления значения URI.
       // Path path2 = Paths.get(new URI("file:///c:/zoo-info/November/employees.txt"));

        //Path.getPath()Метод , используемый на протяжении предыдущих примеров фактически
        // обсчитывать для класса java.nio.file.FileSystemметода getPath(). У FileSystemкласса
        // есть protectedконструктор, поэтому мы используем FileSystemsкласс фабрики множественного числа
        // для получения экземпляра FileSystem, как показано в следующем примере кода:
        //
        //Path path1 = FileSystems.getDefault().getPath("pandas/cuddly.png");

        //Хотя в большинстве случаев нам нужен доступ к Pathобъекту,
        // который находится в локальной файловой системе, FileSystemsкласс фабрики дает нам возможность
        // подключаться к удаленной файловой системе, как показано в следующем примере кода:

        //FileSystem fileSystem = FileSystems.getFileSystem(
         //       new URI("http://www.selikoff.net"));
        //Path path = fileSystem.getPath("duck.txt");
        //Этот код полезен, когда нам нужно Pathчасто создавать объекты для удаленной файловой системы.
        // Сила API NIO.2 в этом заключается в том, что он позволяет нам полагаться на файловую систему
        // по умолчанию для файлов и каталогов, как и прежде, давая нам возможность
        // создавать более сложные приложения, которые ссылаются на внешние файловые системы.



        //Взаимодействие с файлами
        //Большой! Теперь у нас есть доступ к Pathобъекту, и мы можем узнать массу информации о нем,
        // но что мы можем сделать с файлом, на который он ссылается? Для начала, многие из тех же самых операций,
        // доступных в java.io.File, доступны java.nio.file.Pathчерез вспомогательный класс с
        // именем java.nio.file.Filesили Filesдля краткости. В отличие от методов в Pathи Pathsкласса,
        // большинство из вариантов в пределах Filesкласса будет сгенерировано исключение ,
        // если файл , к которому Pathотносится не существует.
        //
        // Тестирование пути с существует ()
        //Files.exists(Path)Метод принимает Pathобъект и возвращает , trueесли и только если он ссылается на файл ,
        // который существует в файловой системе.
        //Давайте посмотрим на пример кода:
        System.out.println(Files.exists(Paths.get("/ostrich/feathers.png")));


    }
}
