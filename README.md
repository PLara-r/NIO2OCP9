# NIO2OCP9

1)Взаимодействие с файлами

Большой! Теперь у нас есть доступ к Pathобъекту, и мы можем узнать массу информации о нем, но что мы можем сделать с файлом, на который он ссылается? Для начала, многие из тех же самых операций, доступных в java.io.File, доступны java.nio.file.Pathчерез вспомогательный класс с именем java.nio.file.Filesили Filesдля краткости. В отличие от методов в Pathи Pathsкласса, большинство из вариантов в пределах Filesкласса будет сгенерировано исключение , если файл , к которому Pathотносится не существует.



Таблица 9.5 Сравнение устаревшихFileметодов и методов NIO.2


Legacy Method	NIO.2 Method
file.exists()	Files.exists(path)
file.getName()	path.getFileName()
file.getAbsolutePath()	path.toAbsolutePath()
file.isDirectory()	Files.isDirectory(path)
file.isFile()	Files.isRegularFile(path)
file.isHidden()	Files.isHidden(path)
file.length()	Files.size(path)
file.lastModified()	Files.getLastModifiedTime(path)
file.setLastModified(time)	Files.setLastModifiedTime(path,fileTime)
file.delete()	Files.delete(path)
file.renameTo(otherFile)	Files.move(path,otherPath)
file.mkdir()	Files.createDirectory(path)
file.mkdirs()	Files.createDirectories(path)
file.listFiles()	Files.list(path)
Имейте в виду, что в API NIO.2 доступен ряд методов и функций, недоступных в устаревшем API, таких как поддержка символических ссылок, установка владельца файла,и так далее. Как и ожидалось, NIO.2 API является гораздо более развитым, гораздо более мощным API, чем унаследованный java.io.Fileкласс, описанный в главе 8.

2) Создание экземпляров с помощью фабричных и вспомогательных классов API NIO.2 
API NIO.2 эффективно использует фабричный шаблон, как описано в главе 2 «Шаблоны и принципы проектирования». Помните, что фабричный класс может быть реализован с использованием staticметодов для создания экземпляров другого класса. Например, вы можете создать экземпляр Pathинтерфейса, используя staticметод, доступный в Pathsфабричном классе. Обратите внимание sна конец Pathsкласса, чтобы отличить его от Pathинтерфейса.
Почему Path - это интерфейс?
Вы можете Pathспросить: «Если это основная точка входа NIO.2, почему я не вызываю Pathконструктор напрямую?» Причина, по которой Pathинтерфейс, а не класс, заключается в том, что создание файла или каталога считается зависимой от файловой системы задачей в NIO.2. Когда вы получаете Pathобъект из файловой системы по умолчанию в NIO.2, JVM возвращает вам объект, который в отличие от java.io.Fileпрозрачно обрабатывает специфичные для системы детали для текущей платформы.
Если вы не использовали шаблон фабрики для создания экземпляра, вам нужно было бы знать, что представляет собой базовая файловая система, и использовать это в каждом методе create. Это сделает ваш код сложным и трудным для переноса на другие файловые системы. Фактически, единственный раз, когда вы реализуете или создаете экземпляр Pathобъекта напрямую, это если бы вы писали код для взаимодействия с файловой системой вашего типа.
Преимущество использования фабричного шаблона в том, что вы можете написать один и тот же код, который будет работать на различных платформах. Как вы увидите в этой главе, не все файловые системы одинаковы; поэтому один и тот же код может иметь разные результаты при запуске в разных файловых системах. Например, системы Linux чувствительны к регистру, а системы на основе Windows - нет, и это различие может изменить ожидаемые результаты программы. Предоставляя различные Pathреализации для каждой платформы, Java может эффективно обрабатывать эти различия.
NIO.2 также включает вспомогательные классы, такие как java.nio.file.Files, чья основная цель заключается в работе с экземплярами Pathобъектов. Вспомогательные или служебные классы похожи на фабричные классы тем, что они часто состоят в основном из staticметодов, которые работают с определенным классом. Они отличаются тем, что вспомогательные классы ориентированы на манипулирование или создание новых объектов из существующих экземпляров, тогда как фабричные классы ориентированы в первую очередь на создание объектов.
Вы должны освоиться с этой парадигмой, если вы этого еще не сделали, поскольку для большинства ваших взаимодействий с API NIO.2 потребуется доступ как минимум к двум классам: интерфейсу и классу фабрики или вспомогательного класса. В качестве руководства для этого раздела мы представляем класс NIO.2 и отношения интерфейса на рисунке 9.1 .
Рисунок 9.1 Класс NIO.2 и интерфейсные отношения
 Создание путей
Поскольку Pathэто интерфейс, вам нужен фабричный класс для создания экземпляров одного класса. API NIO.2 предоставляет ряд классов и методов, которые вы можете использовать для создания Pathобъектов, которые мы рассмотрим в этом разделе.
Использование класса Paths
Самый простой и простой способ получить Pathобъект - использовать java.nio.files.Pathsфабричный класс или, если Pathsкоротко. Чтобы получить ссылку на файл илидиректории, вы бы вызвали staticметод Paths.getPath(String)метода, как показано в следующих примерах:
Path path1 = Paths.get("pandas/cuddly.png"); 
Path path2 = Paths.get("c:\\zooinfo\\November\\employees.txt"); 
Path path3 = Paths.get("/home/zoodirector");
В первом примере создается Pathссылка на относительный файл в текущем рабочем каталоге. Во втором примере создается Pathссылка на абсолютный файл в системе на основе Windows. В третьем примере создается Pathссылка на абсолютный каталог в системе на основе Linux или Mac.
Относительно абсолютного и относительного зависит файловая система
В объяснении предыдущих примеров мы описали пути как абсолютные или относительные в конкретной файловой системе. Это потому, что некоторые пути, которые считаются абсолютными в одних файловых системах, считаются относительными в других. Например, путь c:\zooinfo\November\employees.csvв предыдущем примере наборе считаются относителен системой Linux или Mac на основе, так как она не начинается с косыми чертами, /. Аналогично, путь /home/zoodirectorсчитается относительным в системе на основе Windows, поскольку он не начинается с буквы диска.
Для экзамена и по всему тексту вы можете использовать следующие правила, чтобы определить, является ли путь абсолютным или относительным. Просто имейте в виду, что это может отличаться в зависимости от вашей файловой системы.
•	Если путь начинается с косой черты, это абсолютный путь, например /bird/parrot.
•	Если путь начинается с буквы диска, это абсолютный путь, например C:\bird\emu.
•	В противном случае это относительный путь, например ..\eagle.
Кроме того, можно создать с Pathпомощью Pathsкласса , используя vararg типа String, например Paths.get(String,String...). Это позволяет создавать Pathиз списка Stringзначений, в которых зависимая от операционной системы path.separatorавтоматически вставляется между элементами. Как вы, возможно, помните из главы 8, System.getProperty("path.separator")может использоваться для получения зависимого от операционной системы разделителя файлов из JVM. При этом большинство реализаций JVM поддерживают как прямую, так и обратную косую черту независимо от файловой системы, что позволяет запускать один и тот же код в нескольких операционных системах без необходимости перезаписывать косые черты.

Path path1 = Paths.get("pandas","cuddly.png");
Path path2 = Paths.get("c:","zooinfo","November","employees.txt");
Path path3 = Paths.get("/","home","zoodirector");
Эти примеры переписывают наш предыдущий набор Pathпримеров, используя список Stringзначений параметров вместо одного Stringзначения. Преимущество использования этого перегруженного метода заключается в том, что он более надежен при ручном построении значений пути, поскольку он вставляет правильный разделитель пути для вас.
Будьте осторожны с путями против путей на экзамене
Как вы видели в главе 3 «Обобщения и коллекции» с Collectionинтерфейсом и Collectionsклассом, Java любит использовать одно имя для класса данных и множественную форму этого имени для фабричного или вспомогательного класса. Когда вы видите вопросы во время Pathили Pathsна экзамене, убедитесь, что ссылка на класс и его использование правильные. Например, следующее использование некорректно и не будет компилироваться:

Paths path1 = Paths.get("/alligator/swim.txt");  // DOES NOT COMPILE
Path path2 = Path.get("/crocodile/food.csv");  // DOES NOT COMPILE
В первом примере Pathобъект присваивается Pathsэкземпляру, что несовместимо. Во втором примере, есть попытка получить доступ к методу , который не существует, Path.get("String").
Необходимо помнить, что форма единственного числа Pathпредставляет экземпляр, с которым вы хотите работать, тогда как форма множественного числа Paths- это фабричный класс, содержащий методы для создания Pathэкземпляров.
Другой способ построить с Pathиспользованием Pathsкласса является со значением URI. uniform resource identifier(URI) представляет собой строку символов , которые идентифицируют ресурс. Он начинается со схемы, которая указывает тип ресурса, за которым следует значение пути. Примеры значений схемы включают в себя file://, http://, https://, и ftp://. java.net.URIКласс используется для создания и управления значения URI.

Path path1 = Paths.get(new URI("file://pandas/cuddly.png")); // THROWS EXCEPTION  	// AT RUNTIME
Path path2 = Paths.get(new URI("file:///c:/zoo-info/November/employees.txt"));
Path path3 = Paths.get(new URI("file:///home/zoodirectory"));
Эти примеры показывают, как Paths.get(URI)метод можно использовать для получения ссылки на ресурс на основе URI. Обратите внимание, что это на самом деле переписано в наших предыдущих примерах, поскольку мы можем использовать значения URI как для локальных, так и для сетевых путей. Первый пример фактически генерирует исключение во время выполнения, поскольку URI должны ссылаться на абсолютные пути во время выполнения. У класса URI есть isAbsolute()метод, хотя это связано с тем, имеет ли URI схему, а не местоположение файла.
Теперь мы представим два дополнительных метода, которые используют другие типы схем нелокальной файловой системы. Для экзамена вам не нужно знать синтаксис этих схем, но вы должны знать, что они существуют.

Path path4 = Paths.get(new URI("http://www.wiley.com"));
Path path5 = Paths.get(    
new URI("ftp://username:password@ftp.the-ftp-server.com"));
Обратите внимание, что конструктор new URI(String)выбрасывает проверенный URISyntaxException, который должен быть обнаружен в любом приложении, где используются предыдущие фрагменты кода.
Наконец, Pathинтерфейс также содержит взаимный метод toUri()для преобразования Pathэкземпляра обратно в URIэкземпляр, как показано в следующем примере кода:

Path path4 = Paths.get(new URI("http://www.wiley.com"));
URI uri4 = path4.toUri();

Доступ к базовому объекту FileSystem
Path.getPath()Метод , используемый на протяжении предыдущих примеров фактически обсчитывать для класса java.nio.file.FileSystemметода getPath(). У FileSystemкласса есть protectedконструктор, поэтому мы используем FileSystemsкласс фабрики множественного числа для получения экземпляра FileSystem, как показано в следующем примере кода:

Path path1 = FileSystems.getDefault().getPath("pandas/cuddly.png");
Path path2 = FileSystems.getDefault().getPath("c:","zooinfo","November",    "employees.txt");
Path path3 = FileSystems.getDefault().getPath("/home/zoodirector");
Опять же, мы можем переписать наш предыдущий набор примеров, причем этот код ведет себя точно так же, как и раньше.
Хотя в большинстве случаев нам нужен доступ к Pathобъекту, который находится в локальной файловой системе, FileSystemsкласс фабрики дает нам возможность подключаться к удаленной файловой системе, как показано в следующем примере кода:

FileSystem fileSystem = FileSystems.getFileSystem(   
 new URI("http://www.selikoff.net"));
Path path = fileSystem.getPath("duck.txt");
Этот код полезен, когда нам нужно Pathчасто создавать объекты для удаленной файловой системы. Сила API NIO.2 в этом заключается в том, что он позволяет нам полагаться на файловую систему по умолчанию для файлов и каталогов, как и прежде, давая нам возможность создавать более сложные приложения, которые ссылаются на внешние файловые системы. 
